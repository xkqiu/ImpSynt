
include "header/aux.skh";


#define SLL 0
#define SLLSEG 1
#define TREE 2
#define KEYLEQTO 3
#define MAXSEGEQ 4
#define MINSEGEQ 5
#define LENSEGEQ 6
#define MAXLEQMIN 7
#define RSLL 8
#define RSLLSEG 9
#define DISJ 10
#define NEXTTO 11

bit sll(int l, int t);
bit rsll(int l, int t);
int len(int l, int t);
int min(int l, int t);
int max(int l, int t);
bit sllseg(int l1, int t);
bit rsllseg(int l1, int t);
int minseg(int l1, int t);
int maxseg(int l1, int t);
int lenseg(int l1, int t);


bit sll_comp(int l) {
	//assert (treeness(l));
	return sll_recursive(l, BOUND);
}

bit sll_recursive(int l, int bnd) {
	if (l < 0 || l >= HEAPSIZE) return false;
	if (!active[l]) return false;
	if (l == 0) return true;
	if (bnd < 0){ return 0; }
	else {
		if (symbolic[l]) return sll_history(l, ts);
		else if (0 == next[l]) return true;
		else if (0 < next[l] && next[l] < HEAPSIZE) return sll_recursive(next[l], bnd-1) && key[l] <= min_recursive(next[l], bnd-1);
		else if (0 == supernext[l]) return true;
		else if (0 < supernext[l] && supernext[l] < HEAPSIZE) return sllseg_history(l, ts) && sll_recursive(supernext[l], bnd-1) && maxseg_history(l, ts) <= min_recursive(supernext[l], bnd-1);
		else return false;
	}
}

bit sll_history(int l, int ts) {
	while (ts > 0 && history[l,ts]) ts--;
	return sll(l, ts);
}

bit sllseg_comp(int l1, int l2) {
	//assert (p_treeness(l1, l2));
	return sllseg_recursive(l1, l2, BOUND);
}

bit sllseg_recursive(int l1, int l2, int bnd) {
	if (!active[l1] || !active[l2]) return false;
	else if (l1 == l2) return true;
	else if (l1 == 0) return false;
	else if (bnd < 0){ return 0; }
	else {
		if (symbolic[l1]) return false;
		else if (0 == next[l1]) return (l2 == 0);
		else if (0 < next[l1] && next[l1] < HEAPSIZE) return sllseg_recursive(next[l1], l2, bnd-1) && key[l1] <= minseg_recursive(next[l1], l2, bnd-1);
		else if (0 == supernext[l1]) return (sllseg_history(l1, ts) && l2 == 0);
		else if (0 < supernext[l1] && supernext[l1] < HEAPSIZE) return sllseg_history(l1, ts) && sllseg_recursive(supernext[l1], l2, bnd-1) && maxseg_history(l1, ts) <= minseg_recursive(supernext[l1], l2, bnd-1);
		else return false;
	}
}

bit sllseg_history(int l1, int ts) {
	while (ts > 0 && p_history[l1,ts]) ts--;
	return sllseg(l1, ts);
}

bit rsll_comp(int l) {
	//assert (treeness(l));
	return rsll_recursive(l, BOUND);
}

bit rsll_recursive(int l, int bnd) {
	if (!active[l]) return false;
	else if (l == 0) return true;
	else if(bnd < 0) return false;
	else {
		if (symbolic[l]) return rsll_history(l, ts);
		else if (0 == next[l]) return true;
		else if (0 < next[l] && next[l] < HEAPSIZE) return rsll_recursive(next[l], bnd-1) && key[l] >= max_recursive(next[l], bnd-1);
		else if (0 == supernext[l]) return true;
		else if (0 < supernext[l] && supernext[l] < HEAPSIZE) return rsllseg_history(l, ts) && rsll_recursive(supernext[l], bnd-1) && minseg_recursive(l, supernext[l], bnd-1) >= max_recursive(supernext[l], bnd-1);
		else return 0;
	}
}

bit rsll_history(int l, int ts) {
	while (ts > 0 && history[l,ts]) ts--;
	return rsll(l, ts);
}

bit rsllseg_comp(int l1, int l2) {
	//assert (p_treeness(l1, l2));
	return rsllseg_recursive(l1, l2, BOUND);
}

bit rsllseg_recursive(int l1, int l2, int bnd) {
	if (!active[l1] || !active[l2]) return false;
	else if (l1 == l2) return true;
	else if (l1 == 0) return false;
	else if (bnd < 0){ return 0; }
	else {
		if (symbolic[l1]) return false;
		else if (0 == next[l1]) return (l2 == 0);
		else if (0 < next[l1] && next[l1] < HEAPSIZE) return rsllseg_recursive(next[l1], l2, bnd-1) && key[l1] >= maxseg_recursive(next[l1], l2, bnd-1);
		else if (0 == supernext[l1]) return (rsllseg_history(l1, ts) && l2 == 0);
		else if (0 < supernext[l1] && supernext[l1] < HEAPSIZE) return rsllseg_history(l1, ts) && rsllseg_recursive(supernext[l1], l2, bnd-1) && minseg_history(l1, ts) >= maxseg_recursive(supernext[l1], l2, bnd-1);
		else return false;
	}
}

bit rsllseg_history(int l1, int ts) {
	while (ts > 0 && p_history[l1,ts]) ts--;
	return rsllseg(l1, ts);
}

int len_comp(int l) {
	//assert (p_treeness(l, 0));
	return len_recursive(l, 0, BOUND);
}

int len_recursive(int l1, int l2, int bnd) {
	if (l1 < 0 || l1 >= HEAPSIZE || l2 < 0 || l2 >= HEAPSIZE) return -1;
	else if (!active[l1] || !active[l2]) return -1;
	//workaround
	else if (l1 == l2) return (l1 == 0 || symbolic[l1] || next[l1] != l1) ? 0 : 1;
	//not sure
	else if (l1 == 0) return -1;
	else if(bnd < 0){ return -1; }
	else {
		if (symbolic[l1]) {
			if (l2 == 0) return len_history(l1, ts);
			else return -1;
		}
		//workaround
		else if (l2 == next[l1]) return (l2 == 0 || symbolic[l2] || next[l2] != l2) ? 1 : 2;
		else if (0 == next[l1]) return -1;
		else if (0 < next[l1] && next[l1] < HEAPSIZE) return len_recursive(next[l1], l2, bnd-1) + 1;
		else if (l2 == supernext[l1]) return lenseg_history(l1, ts);
		else if (0 == supernext[l1]) return -1;
		else if (0 < supernext[l1] && supernext[l1] < HEAPSIZE) return lenseg_history(l1, ts) + len_recursive(supernext[l1], l2, bnd-1);
		else return -1;
	}
}

int len_history(int l, int ts) {
	while (ts > 0 && history[l,ts]) ts--;
	return len(l, ts);
}

int lenseg_comp(int l1, int l2) {
	//assert (p_treeness(l1, l2));
	return len_recursive(l1, l2, BOUND);
}

int lenseg_history(int l1, int ts) {
	while (ts > 0 && p_history[l1,ts]) ts--;
	return lenseg(l1, ts);
}

int min_comp(int l) {
	//assert (treeness(l));
	return min_recursive(l, BOUND);
}

int min_recursive(int l, int bnd) {
	return minseg_recursive(l, 0, bnd);
}

int min_history(int l, int ts) {
	while (ts > 0 && history[l,ts]) ts--;
	return min(l, ts);
}

int minseg_comp(int l1, int l2) {
	//assert (p_treeness(l1, l2));
	return minseg_recursive(l1, l2, BOUND);
}

int minseg_recursive(int l1, int l2, int bnd) {
	if (l1 < 0 || l1 >= HEAPSIZE) return INTMAX;
	else if (!active[l1]) return INTMAX;
	//workaround
	else if (l1 == l2) return (l1 == 0 || symbolic[l1] || next[l1] != l1) ? INTMAX : key[l1];
	//not sure
	else if (l1 == 0) return INTMAX;
	else if(bnd < 0) return -1;
	else {
		if (symbolic[l1]) {
			if (l2 == 0) return min_history(l1, ts);
			else return -1;
		}
		else if (l2 == next[l1]) return (l2 == 0 || symbolic[l2] || next[l2] != l2 || key[l1] <= key[l2]) ? key[l1] : key[l2];
		else if (0 == next[l1]) return -1;
		else if (0 < next[l1] && next[l1] < HEAPSIZE) {
			int r = minseg_recursive(next[l1], l2, bnd-1);
			return (key[l1] <= r) ? key[l1] : r;
		}
		else if (l2 == supernext[l1]) return minseg_history(l1, ts);
		else if (0 == supernext[l1]) return -1;
		else if (0 < supernext[l1] && supernext[l1] < HEAPSIZE) {
			int p1 = minseg_history(l1, ts);
			int p2 = minseg_recursive(supernext[l1], l2, bnd-1);
			return p1 <= p2 ? p1 : p2;
		}
		else return -1;
	}
}

int minseg_history(int l1, int ts) {
	while (ts > 0 && p_history[l1, ts]) ts--;
	return minseg(l1, ts);
}

int max_comp(int l) {
	//assert (treeness(l));
	return max_recursive(l, BOUND);
}

int max_recursive(int l, int bnd) {
	return maxseg_recursive(l, 0, bnd);
}

int max_history(int l, int ts) {
	while (ts > 0 && history[l,ts]) ts--;
	return max(l, ts);
}

int maxseg_comp(int l1, int l2) {
	//assert (p_treeness(l1, l2));
	return maxseg_recursive(l1, l2, BOUND);
}

int maxseg_recursive(int l1, int l2, int bnd) {
	if (l1 < 0 || l1 >= HEAPSIZE || l2 < 0 || l2 >= HEAPSIZE) return -1;
	else if (!active[l1] || !active[l2]) return -1;
	else if (l1 == l2) return (l1 == 0 || symbolic[l1] || next[l1] != l1) ? 0 : key[l1];
	//not sure
	else if (l1 == 0) return 0;
	else if (bnd < 0) return -1;
	else {
		if (symbolic[l1]) {
			if (l2 == 0) return max_history(l1, ts);
			else return -1;
		}
		else if (l2 == next[l1]) return (l2 == 0 || symbolic[l2] || next[l2] != l2 || key[l2] <= key[l1]) ? key[l1] : key[l2];
		else if (0 == next[l1]) return -1;
		else if (0 < next[l1] && next[l1] < HEAPSIZE) {
			int r = maxseg_recursive(next[l1], l2, bnd-1);
			return (key[l1] >= r) ? key[l1] : r;
		}
		else if (l2 == supernext[l1]) return maxseg_history(l1, ts);
		else if (0 == supernext[l1]) return -1;
		else if (0 < supernext[l1] && supernext[l1] < HEAPSIZE) {
			int p1 = maxseg_history(l1, ts);
			int p2 = maxseg_recursive(supernext[l1], l2, bnd-1);
			return p1 >= p2 ? p1 : p2;
		}
		else return -1;
	}
}

int maxseg_history(int l1, int ts) {
	while (ts > 0 && p_history[l1, ts]) ts--;
	return maxseg(l1, ts);
}


bit check_treeness(int t, ref bit[HEAPSIZE] m, int bnd) {
	return check_p_treeness(t, 0, m, bnd);
	
	/*if(bnd < 0) { return 0; }
	if (t == 0) return true;
	else if (!active[t]) return false;
	
    else if (symbolic[t]) {
    	if (m[t]) return false;
    	else {
    		m[t] = true;
    		return true;
    	}
    }
    else {
    	if (m[t]) return false;
        else {
            m[t] = true;
            if (next[t] == 0) return true;
            else if (next[t] > 0 && next[t] < HEAPSIZE) return check_treeness(next[t], m, bnd-1);
            else return false;
        }
    }*/
}

bit treeness(int t) {
	bit[HEAPSIZE] visited = 0;
	return check_p_treeness(t, 0, visited, BOUND);
	//return check_treeness(t, visited, BOUND);
}

bit check_p_treeness(int t1, int t2, ref bit[HEAPSIZE] m, int bnd) {
	if(bnd < 0) { return 0; }
	else if (t1<0 || t1>=HEAPSIZE || t2<0 || t2>=HEAPSIZE) return false;
	else if (!active[t1] || !active[t2]) return false;
    else if (t1 == t2) return true;
    else if (t1 == 0) return false;
    else if (symbolic[t1]) {
    	if (m[t1]) return false;
    	else {
    		m[t1] = true;
    		return t2 == 0;
    	}
    }
    else {
    	if (m[t1]) return false;
        else {
            m[t1] = true;
            int nxt = next[t1];
            if (nxt < 0 || nxt >= HEAPSIZE) nxt = supernext[t1];
            if (nxt == 0) return t2 == 0;
            else if (nxt < 0 || nxt >= HEAPSIZE) return false;
            else return check_p_treeness(nxt, t2, m, bnd-1);
            //if (next[t1] >= 0 && next[t1] < HEAPSIZE) return check_p_treeness(next[t1], t2, m, bnd-1);
            //else if (supernext[t1] >= 0 && supernext[t1] < HEAPSIZE) return check_p_treeness(supernext[t1], t2, m, bnd-1);
            //else return false;
        }
    }
}

bit p_treeness(int t1, int t2) {
	bit[HEAPSIZE] visited = 0;
	return check_p_treeness(t1, t2, visited, BOUND);
}


bit singleTree(int v) {
	assert v >= 0 && v < HEAPSIZE;
	int r = locvars[v];
	if (r == 0) return true;
	bit[HEAPSIZE] reach = 0;
	compute_reach(r, 0, reach);
	bit res = true;
	for (int idx = 1; idx < HEAPSIZE; idx++) {
		if (reach[idx] != active[idx]) res = false;
	}
	return res;
}

/*

void assertTwoDisjointTrees(int r1, int r2) {
	compute_reach(r1);
	bit[HEAPSIZE] temp = 0;
	for (int idx = 1; idx < HEAPSIZE; idx++) {
		if (!active[idx]) {
			assert !reach[idx];
		} else if (!reach[idx]) {
			temp[idx] = 1;
		}
	}
	reach = 0;
	compute_reach(r2);
	for (int idx = 1; idx < HEAPSIZE; idx++) {
		assert (reach[idx] == temp[idx]);
	}
}
*/

bit disjoint(int r1, int r2, int r3, int r4) {
	bit[HEAPSIZE] temp1 = 0;
	compute_reach(r1, r3, temp1);
	bit[HEAPSIZE] temp2 = 0;
	compute_reach(r2, r4, temp2);
	// still not sure how to handle the disjointness of (a, a) and (a, b)
	if (r1 != r2 && (temp1[r2] || temp2[r1])) return false;
	if (r1 == r2 && next[r1] == r1) return false;
	for (int idx = 1; idx < HEAPSIZE; idx++) {
		if (temp1[idx] && temp2[idx]) return false;
	}
	return true;
}

// currently the stop location is included? May need to be removed at some point
void update_reach(ref bit updated, ref bit[HEAPSIZE] reach, int stop) {
	for (int i = 1; i < HEAPSIZE; i++) {
		if (reach[i] && active[i] && !symbolic[i] && i != stop) {
			int n = next[i];
			if (!(n >= 0 && n < HEAPSIZE)) n = supernext[i];
			if (!(n >= 0 && n < HEAPSIZE)) n = -1;
			if (n > 0 && active[n] && !reach[n]) {
				reach[n] = true;
				updated = true;
			}
		}
	}
}

void compute_reach(int init, int stop, ref bit[HEAPSIZE] reach) {
	if (init < 0 || init >= HEAPSIZE) return;
	else if (!active[init]) return;
	reach[init] = (init == stop) ? 0 : 1;
	bit updated = false;
	do {
		updated = false;
		update_reach(updated, reach, stop);
	}
	while (updated);
}


int havoc(int r, ref bit[HEAPSIZE-1] new_symbolic, ref int[HEAPSIZE-1] new_next, ref int[HEAPSIZE-1] new_supernext, ref int[HEAPSIZE-1] new_key) {
	/* havoc all locations reachable from r */
	bit[HEAPSIZE] reach = 0;
	compute_reach(r, 0, reach);
	for (int idx = 1; idx < HEAPSIZE; idx++) {
		if (reach[idx]) active[idx] = false;
		if (!active[idx]) {
			symbolic[idx] = new_symbolic[idx-1];
			next[idx] = new_next[idx-1];
			supernext[idx] = new_supernext[idx-1];
			key[idx] = new_key[idx-1];
		}
	}
	
	int loc = 1;
	while (loc < HEAPSIZE && (active[loc] || !symbolic[loc])) {
    	loc++;
    }
    if (loc >= HEAPSIZE) return 0; //only nil can be returned
    
    ts++;
	connect_defs();
    
    //nondeterministic choice
    active[loc] = true;
    
    return loc;
}

void locderef2var(int c1, int c2) {
	/* pick two loc vars, then choice2 = choice.next */
	int choice = c1;
	assert choice > 0;
	assert choice < LOCVARSIZE;
	int choice2 = c2;
	assert choice2 > 0;
	assert choice2 < LOCVARSIZE;
	
	/* sanity check */
	int l = locvars[choice];
	assertPost(l > 0);
	assertPost(l < HEAPSIZE);
	if (l <= 0 || l >= HEAPSIZE) return;
	if (!active[l]) return;
	
	
	int test = next[l];
    
    if (!symbolic[l]) {
    	assumePre(test >= 0);
    	assumePre(test < HEAPSIZE);
    	if (test < 0 || test >= HEAPSIZE) {
    		return;
    	}
    	locvars[choice2] = test;
    	return;
    }
    
    int ln = test;
	if (test > 0) {
		assumePre(malloc_budget >= 1);
    	if (malloc_budget < 1) return;
    	malloc_budget--;
    	
    	ln = 1;
    	while (ln < HEAPSIZE && active[ln]) {
    		ln++;
    	}
    	assumePre(ln < HEAPSIZE);
    	if (ln >= HEAPSIZE) return;
    	
    	
    	active[ln] = true;
    	symbolic[ln] = true;
    	next[l] = ln;
    }
    
    locvars[choice2] = ln;
    symbolic[l] = false;
    
    assumePre(sll(l, ts) == sll_comp(l));
    //assumePre(rsll(l, ts) == rsll_comp(l));
    assumePre(len(l, ts) == len_comp(l));
    assumePre(min(l, ts) == min_comp(l));
    assumePre(max(l, ts) == max_comp(l));
}

void intderef2var(int c1, int c2) {
	/* pick two loc vars, then choice2 = choice.key */
	int choice = c1;
	assert choice > 0;
	assert choice < LOCVARSIZE;
	int choice2 = c2;
	assert choice2 >= 0;
	assert choice2 < INTVARSIZE;
	
	/* sanity check */
	int l = locvars[choice];
	assertPost(l > 0);
	assertPost(l < HEAPSIZE);
	if (l <= 0 || l >= HEAPSIZE) return;
	if (!active[l]) return;
	
	
    int test = next[l];
    
    if (!symbolic[l]) {
    	assumePre(test >= 0);
    	assumePre(test < HEAPSIZE);
    	if (test < 0 || test >= HEAPSIZE) {
    		return;
    	}
    	intvars[choice2] = key[l];
    	return;
    }
    
    
    int ln = test;
	if (test > 0) {
    	ln = 1;
    	while (ln < HEAPSIZE && active[ln]) {
    		ln++;
    	}
    	assumePre(ln < HEAPSIZE);
    	if (ln >= HEAPSIZE) return;
    	
    	
    	active[ln] = true;
    	symbolic[ln] = true;
    	next[l] = ln;
    }
    
    intvars[choice2] = key[l];
    symbolic[l] = false;
    
    assumePre(sll(l, ts) == sll_comp(l));
    //assumePre(rsll(l, ts) == rsll_comp(l));
    assumePre(len(l, ts) == len_comp(l));
    assumePre(min(l, ts) == min_comp(l));
    assumePre(max(l, ts) == max_comp(l));
}

void malloc(int c) {
	/* pick a loc var, then choice = malloc() */
    
	int choice = c;
	assert choice > 0;
	assert choice < LOCVARSIZE;
	
	assert malloc_budget >= 1;
	assumePre(malloc_budget >= 1);
    if (malloc_budget < 1) return;
    malloc_budget--;
	
	int l = 1;
    while (l < HEAPSIZE && active[l]) {
    	l++;
    }
    assumePre(l < HEAPSIZE);
    if (l >= HEAPSIZE) return;
    
    next[l] = 0;
    key[l] = 0;
    symbolic[l] = false;
    active[l] = true;
    locvars[choice] = l;
}

void free(int c) {
	/* pick a loc var, then choice = malloc() */
    
	int choice = c;
	assert choice > 0;
	assert choice < LOCVARSIZE;
	
	int l = locvars[choice];
	
	//assumePre(active[l] && !symbolic[l]);
	assertPost(active[l] && !symbolic[l]);
	if (!active[l] || symbolic[l]) return;
	
	if (l > 0 && l < HEAPSIZE) {
		active[l] = false;
		malloc_budget++;
		ts++;
		connect_defs();
	}
    
}


bit locderef_eq_nil(int c1) {
	int choice = c1;
	assert choice > 0;
	assert choice < LOCVARSIZE;
	
	/* sanity check */
	int l = locvars[choice];
	assertPost(l > 0);
	assertPost(l < HEAPSIZE);
	if (l <= 0 || l >= HEAPSIZE) return false;
	if (!active[l]) return false;
	
	
	int test = next[l];
    
    if (!symbolic[l]) {
    	assumePre(test >= 0);
    	assumePre(test < HEAPSIZE);
    	if (test < 0 || test >= HEAPSIZE) {
    		return false;
    	}
    }
    
	if (test == 0) {
		symbolic[l] = false;
		assumePre(sll(l, ts) == sll_comp(l));
    	//assumePre(rsll(l, ts) == rsll_comp(l));
    	assumePre(len(l, ts) == len_comp(l));
    	assumePre(minseg(l, ts) == min_comp(l));
    	assumePre(maxseg(l, ts) == max_comp(l));
    	return true;
	}
	else return false;
}

bit intderef_lt_var(int c1, int c2) {
	/* c1.key < c2 */
	int choice = c1;
	assert choice > 0;
	assert choice < LOCVARSIZE;
	int choice2 = c2;
	assert choice2 >= 0;
	assert choice2 < INTVARSIZE;
	
	/* sanity check */
	int l = locvars[choice];
	assertPost(l > 0);
	assertPost(l < HEAPSIZE);
	if (l <= 0 || l >= HEAPSIZE) return false;
	if (!active[l]) return false;
	
	
	int test = next[l];
    
    if (!symbolic[l]) {
    	assumePre(test >= 0);
    	assumePre(test < HEAPSIZE);
    	if (test < 0 || test >= HEAPSIZE) {
    		return false;
    	}
    	return key[l] < intvars[choice2];
    }
    
    
    int ln = test;
	if (test > 0) {
    	ln = 1;
    	while (ln < HEAPSIZE && active[ln]) {
    		ln++;
    	}
    	assumePre(ln < HEAPSIZE);
    	if (ln >= HEAPSIZE) return false;
    	
    	assertPost(fake_unfold == 0 || fake_unfold == l);
    	assertPost(fake_unfold_to == 0 || fake_unfold_to == ln);
    	fake_unfold = l;
    	fake_unfold_to = ln;
    	
    	active[ln] = true;
    	symbolic[ln] = true;
    	next[l] = ln;
    }
    
    symbolic[l] = false;
    
    assumePre(sll(l, ts) == sll_comp(l));
    //assumePre(rsll(l, ts) == rsll_comp(l));
    assumePre(len(l, ts) == len_comp(l));
    assumePre(min(l, ts) == min_comp(l));
    assumePre(max(l, ts) == max_comp(l));
    
    if (test > 0) {
    	active[ln] = false;
    }
    symbolic[l] = true;
    
    return key[l] < intvars[choice2];
}

generator bit cond_for_loop(int looplocrange, int locrange, int intrange) {
	//int choice = {| INTDEREFLT | LOCEQ |};

	//Assuming always checking the last loop-related variable?
	int v = looplocrange; //gen_non_zero(looplocrange);
	bit d = ??;
	if (intrange == 0) d = false;
	if (d) { //(choice == INTDEREFLT) {
		assert intrange > 0;
		return (!locvar_eq(v, 0)) && intderef_lt_var(v, gen_all(intrange));
	}
	else { //if (choice == LOCEQ) {
		return !locvar_eq(v, {| 0 | looplocrange + gen_non_zero(locrange) |});
	}
}

generator bit positive_cond(int v, int locrange, int intrange) {
	//int choice = {| INTDEREFLT | LOCEQ |};
	bit d = ??;
	if (intrange == 0) d = false;
	if (d) { //(choice == INTDEREFLT) {
		assert intrange > 0;
		int rrr = gen_all(intrange);
		return (!locvar_eq(v, 0)) && intderef_lt_var(v, rrr);
	}
	else { //if (choice == LOCEQ) {
		return locvar_eq(v, gen_all(locrange+1));
	}
}

generator bit positive_branch_cond(int v, int locrange, int locstart, int intrange, int intstart) {
	//int choice = {| INTDEREFLT | LOCEQ |};
	bit d = ??;
	if (intrange == 0) d = false;
	if (d) { //(choice == INTDEREFLT) {
		assert intrange > 0;
		return (!locvar_eq(v, 0)) && intderef_lt_var(v, gen_range(intstart, intrange));
	}
	else { //if (choice == LOCEQ) {
		return locvar_eq(v, {| 0 | gen_range(locstart, locrange+1) |});
	}
}

generator bit basic_cond(int locrange, int intrange) {
	int lll = gen_non_zero(locrange);
	bit res = positive_cond(lll, locrange, intrange);
	if (??) return res;
	else return !res;
}

generator bit basic_branch_cond(int locrange, int locstart, int intrange, int intstart) {
	bit res = positive_branch_cond(gen_range(locstart, locrange+1), locrange, locstart, intrange, intstart);
	if (??) return res;
	else return !res;
}

/*
generator bit cond() {
	// check the (in)equality between two vars
	bit pos = ??;
	if (??) {
		int choice = ??(2);
		assert choice >= 0;
		assert choice < LOCVARSIZE;
	
		int choice2 = ??(2);
		assert choice2 >= 0;
		assert choice2 < LOCVARSIZE;
	
		if (pos) return {| (locvars[choice] (== | >= | <=) locvars[choice2]) |};
		else return locvars[choice] != locvars[choice2];
	}
	else {
		int choice = ??(2);
		assert choice >= 0;
		assert choice < INTVARSIZE;
	
		int choice2 = ??(2);
		assert choice2 >= 0;
		assert choice2 < INTVARSIZE;
	
		if (pos) return {| (intvars[choice] (== | >= | <=) intvars[choice2]) |};
		else return intvars[choice] != intvars[choice2];
	}
}
*/

generator void statement(int locrange, int intrange, int locrange2, int intrange2) {
	int st_choice = {| LOCDEREF | LOCASSGN | INTDEREF | INTASSGN | MALLOC | FREE | LOCMUTATE | INTMUTATE |};
	int v = gen_non_zero(locrange);
	int anyv = gen_non_zero(locrange+locrange2);
	if (st_choice == LOCDEREF) {
		assert locrange > 0;
		locderef2var(anyv, v);
	}
	else if (st_choice == LOCASSGN) {
		assert locrange > 0;
		locVarAssign(v, gen_all(locrange+locrange2+1));
	}
	else if (st_choice == INTDEREF) {
		assert locrange+locrange2 > 0;
		assert intrange > 0;
		intderef2var(anyv, gen_all(intrange));
	}
	else if (st_choice == INTASSGN) {
		assert intrange > 0;
		intVarAssign(gen_all(intrange), gen_all(intrange+intrange2), ??(3));
	}
	else if (st_choice == MALLOC) {
		assert locrange > 0;
		malloc(v);
	}
	else if (st_choice == FREE) {
		assert locrange+locrange2 > 0;
		free(anyv);
	}
	else if (st_choice == LOCMUTATE) {
		assert locrange+locrange2 > 0;
		locMutate(anyv, gen_all(locrange+locrange2+1), NEXT);
	}
	else if (st_choice == INTMUTATE) {
		assert locrange+locrange2 > 0;
		assert intrange+intrange2 > 0;
		intMutate(anyv, gen_all(intrange+intrange2));
	}
}

generator void mutate_statement(int v, int locrange, int intrange) {
	bit st_choice = ??;
	if (intrange == 0) st_choice = false;
	if (st_choice) {
		assert intrange > 0;
		intMutate(v, gen_all(intrange));
	}
	else {
		assert locrange > 0;
		locMutate(v, gen_non_zero(locrange), NEXT);
	}
}

generator void non_mutate_statement(int locrange, int intrange) {
	int st_choice = {| LOCDEREF | INTDEREF | LOCASSGN | INTASSGN |};
	if (intrange == 0) assert st_choice != INTDEREF && st_choice != INTASSGN;

	if (st_choice == LOCDEREF) {
		assert locrange > 0;
		assert malloc_budget > 0;
		malloc_budget--;
		locderef2var(gen_non_zero(locrange), gen_non_zero(locrange));
	}
	else if (st_choice == INTDEREF) {
		assert locrange > 0 && intrange > 0;
		assert malloc_budget > 0;
		malloc_budget--;
		intderef2var(gen_non_zero(locrange), gen_all(intrange));
	}
	else if (st_choice == LOCASSGN) {
		assert locrange > 0;
		locVarAssign(gen_non_zero(locrange), gen_non_zero(locrange));
	}
	else if (st_choice == INTASSGN) {
		assert intrange > 0;
		intVarAssign(gen_all(intrange), gen_all(intrange), ??(2));
	}
}

generator void update_locvar_statement(int v, int locrange) {
	//int st_choice = {| LOCDEREF | LOCASSGN |};
	if (??) {  //(st_choice == LOCDEREF) {
		assert locrange > 0;
		//assert malloc_budget > 0;
		//malloc_budget--;

		//should mutate gen_non_zero(locrange), but let me assume mutation is only for itself now..
		locderef2var(v, v);
	}
	else { //if (st_choice == LOCASSGN) {
		assert locrange > 0;
		locVarAssign(v, gen_all(locrange+1));
	}
}

generator void update_locvar(int v, int locrange, int intrange) {
	bit choice = ??;
	if (positive_cond(v, locrange, intrange) || choice) update_locvar_statement(v, locrange);
}

generator void update_intvar_statement(int v, int locrange, int intrange) {
	int st_choice = {| INTDEREF | INTASSGN |};
	if (st_choice == INTDEREF) {
		assert locrange > 0;
		//assert malloc_budget > 0;
		//malloc_budget--;
		intderef2var(gen_non_zero(locrange), v);
	}
	else if (st_choice == INTASSGN) {
		assert intrange > 0;
		intVarAssign(v, gen_all(intrange), ??(3));
	}
}

generator void update_intvar(int v, int locrange, int intrange) {
	bit choice = ??;
	if (basic_cond(locrange, intrange) || choice) update_intvar_statement(v, locrange, intrange);
}

generator void mutate_locvar(int v, int locrange, int intrange) {
	bit choice = ??;
	if (positive_cond(v, locrange, intrange) || choice) mutate_statement(v, locrange, intrange);
}

generator void create_node(int v, int locrange, int intrange) {
	assert v > 0;
	assert v < LOCVARSIZE;
	int ghost = v;
	if (locrange >= 3) ghost = (v == 1) ? 2 : 1;
	int temp = locvars[ghost];
	malloc(ghost);
	intMutate(ghost, gen_all(intrange));
	locMutate(ghost, gen_all(locrange+1), NEXT);
	if (ghost != v) {
		locvars[v] = locvars[ghost];
		locvars[ghost] = temp;
	}
}

generator void init_locvar_statement(int v, int locrange, int locrange2, int offset) {
	int st_choice = {| LOCDEREF | LOCASSGN |};
	if (st_choice == LOCDEREF) {
		assert locrange > 0;
		assert malloc_budget > 0;
		malloc_budget--;
		locderef2var({| gen_non_zero(locrange) | (gen_all(locrange2) + offset) |}, v);
	}
	else if (st_choice == LOCASSGN) {
		assert locrange > 0;
		locVarAssign(v, {| gen_non_zero(locrange) | (gen_all(locrange2) + offset) |});
	}
}

/*generator void block(int n, int bnd) {
	if (n == 0) return;
	else if (??) {
		statement();
		block(n-1, bnd);
	}
	else if (bnd < 0) return;
	else {
		int cblock = ??(2);
		int pos = ??(2);
		assert cblock >= 1;
		assert pos >= 0 && pos <= cblock;
		assert cblock < n;
		
		if (cond()) block(pos, bnd-1);
		else block(cblock-pos, bnd-1);
		block(n-cblock-1, bnd-1);
	}
}*/

bit loop_condd() {
    return locvars[3] != 0 && intvars[0] > intvars[2];
	//return cond();
}

/*
generator bit literal(bit asst) {
	int var1 = ??(2);
	int var2 = ??(2);
	assert var1>0 && var1<LOCVARSIZE;
	assert var2>0 && var2<LOCVARSIZE;
	//assert var1 != var2;
	int intvar1 = ??(1);
	int intvar2 = ??(1);
	assert intvar1>=0 && intvar1<INTVARSIZE;
	assert intvar2>=0 && intvar2<INTVARSIZE;
	//assert intvar1 != intvar2;
	
	if (asst)
		assertPost(treeness(locvars[var1]) && treeness(locvars[var2]));
	bit atom = asst;
	if (treeness(locvars[var1]) && treeness(locvars[var2])) {
		int v1 = {| (min_comp(locvars[var1]) | max_comp(locvars[var1]) | len_comp(locvars[var1]) | intvars[intvar1]) |} ;
		int v2 = {| (min_comp(locvars[var2]) | max_comp(locvars[var2]) | len_comp(locvars[var2]) | intvars[intvar2]) |} ;
		int left = {| (v1 | v2 | (v1+v2) | (v1-v2) | (v1<=v2 ? v1 : v2) | (v1>=v2 ? v1 : v2)) |};
		atom = {| (left (== | >= | <=) 0) |};
		if (??) atom = ! atom;
	}

	return atom;
}
*/


void ranking_snapshot(int rec, int v, int v2) {
	assert v>0 && v<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (rec == LEN || rec == MAX || rec == MIN) {
		if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return;
		else if (!treeness(locvars[v])) return;
		else if (rec == LEN) ranking = len_comp(locvars[v]);
		else if (rec == MAX) ranking = max_comp(locvars[v]);
		else if (rec == MIN) ranking = min_comp(locvars[v]);
	}
	else if (rec == LENSEG || rec == MAXSEG || rec == MINSEG) {
		if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return;
		else if (!(locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return;
		else if (!p_treeness(locvars[v], locvars[v2])) return;
		if (rec == LENSEG) ranking = lenseg_comp(locvars[v], locvars[v2]);
		else if (rec == MAXSEG) ranking = maxseg_comp(locvars[v], locvars[v2]);
		else if (rec == MINSEG) ranking = minseg_comp(locvars[v], locvars[v2]);
	}
}

bit ranking_decreases(int rec, int v, int v2) {
	assert v>0 && v<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	int new_ranking = -1;
	if (rec == LEN || rec == MAX || rec == MIN) {
		if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return (ranking == 0);
		//else if (!treeness(locvars[v])) return (ranking == 0);
		else if (rec == LEN) new_ranking = len_comp(locvars[v]);
		else if (rec == MAX) new_ranking = max_comp(locvars[v]);
		else if (rec == MIN) new_ranking = min_comp(locvars[v]);
	}
	else if (rec == LENSEG || rec == MAXSEG || rec == MINSEG) {
		if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return (ranking == 0);
		else if (!(locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return (ranking == 0);
		//else if (!p_treeness(locvars[v], locvars[v2])) return (ranking == 0);
		else if (rec == LENSEG) new_ranking = lenseg_comp(locvars[v], locvars[v2]);
		else if (rec == MAXSEG) new_ranking = maxseg_comp(locvars[v], locvars[v2]);
		else if (rec == MINSEG) new_ranking = minseg_comp(locvars[v], locvars[v2]);
	}
	return ranking > new_ranking && new_ranking >= 0;
}


bit tree_inv(int v) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]);
}

bit sll_inv(int v) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]) && sll_comp(locvars[v]);
}

bit rsll_inv(int v) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]) && rsll_comp(locvars[v]);
}

bit lseg_inv(int v1, int v2) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	else return p_treeness(locvars[v1], locvars[v2]);
}

bit sllseg_inv(int v1, int v2) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	return (p_treeness(locvars[v1], locvars[v2]) && sllseg_comp(locvars[v1], locvars[v2]));
}

bit rsllseg_inv(int v1, int v2) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	return (p_treeness(locvars[v1], locvars[v2]) && rsllseg_comp(locvars[v1], locvars[v2]));
}

bit tree_equal_inv(int v) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]);
}

bit sll_equal_inv(int v) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]) && sll_comp(locvars[v]);
}

bit len_equal_inv(int v, int val) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]) && len_comp(locvars[v]) == val;
}

bit min_equal_inv(int v, int val) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]) && min_comp(locvars[v]) == val;
}

bit max_equal_inv(int v, int val) {
	assert v>0 && v<LOCVARSIZE;
	if (!(locvars[v] >= 0 && locvars[v] < HEAPSIZE)) return false;
	else return treeness(locvars[v]) && max_comp(locvars[v]) == val;
}

bit len_preserve_inv(int val, int v1, int v2, int v3, bit single) {
	assert v1>0 && v1<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE)) return false;
	else if (single)
		return treeness(locvars[v3]) && len_comp(locvars[v3]) == val;
	else {
		//int v1 = gen_non_zero(looplocrange-1);
		//int v2 = gen_non_zero(looplocrange-1)+1;
		assert v1 < v2;
		if (locvars[v1] >= 0 && locvars[v1] < HEAPSIZE
		&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
		&& treeness(locvars[v1]) && treeness(locvars[v2])) {
			int l1 = len_comp(locvars[v1]);
			int l2 = len_comp(locvars[v2]);
			return l1 + l2 == val;
		}
		else return false;
	}
}

bit lenseg_preserve_inv(int val, int v1, int v2, int v3, int v4, bit single) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v3>=0 && v3<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE && locvars[v3] >= 0 && locvars[v3] <= HEAPSIZE)) return false;
	else if (single)
		return p_treeness(locvars[v1], locvars[v3]) && lenseg_comp(locvars[v1], locvars[v3]) == val;
	else {
		//int v1 = gen_non_zero(looplocrange-1);
		//int v2 = gen_non_zero(looplocrange-1)+1;
		assert v1 < v2;
		assert v2>0 && v2<LOCVARSIZE;
		assert v4>=0 && v4<LOCVARSIZE;
		if (! (locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
		&& locvars[v4] >= 0 && locvars[v4] < HEAPSIZE)) return false;
		else if (p_treeness(locvars[v1], locvars[v3]) && p_treeness(locvars[v2], locvars[v4])) {
			int l1 = lenseg_comp(locvars[v1], locvars[v3]);
			int l2 = lenseg_comp(locvars[v2], locvars[v4]);
			return l1 + l2 == val;
		}
		else return false;
	}
}

bit min_preserve_inv(int val, int v1, int v2, int v3, bit single) {
	assert v1>0 && v1<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE)) return false;
	else if (single)
		return treeness(locvars[v3]) && min_comp(locvars[v3]) == val;
	else {
		//int v1 = gen_non_zero(looplocrange-1);
		//int v2 = gen_non_zero(looplocrange-1)+1;
		assert v1 < v2;
		if (locvars[v1] >= 0 && locvars[v1] < HEAPSIZE
		&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
		&& treeness(locvars[v1]) && treeness(locvars[v2])) {
			int m1 = min_comp(locvars[v1]);
			int m2 = min_comp(locvars[v2]);
			return (m1 <= m2 ? m1 : m2) == val;
		}
		else return false;
	}
}

bit minseg_preserve_inv(int val, int v1, int v2, int v3, int v4, bit single) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v3>=0 && v3<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE && locvars[v3] >= 0 && locvars[v3] <= HEAPSIZE)) return false;
	else if (single)
		return p_treeness(locvars[v1], locvars[v3]) && minseg_comp(locvars[v1], locvars[v3]) == val;
	else {
		//int v1 = gen_non_zero(looplocrange-1);
		//int v2 = gen_non_zero(looplocrange-1)+1;
		assert v1 < v2;
		assert v2>0 && v2<LOCVARSIZE;
		assert v4>=0 && v4<LOCVARSIZE;
		if (! (locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
		&& locvars[v4] >= 0 && locvars[v4] < HEAPSIZE)) return false;
		else if (p_treeness(locvars[v1], locvars[v3]) && p_treeness(locvars[v2], locvars[v4])) {
			int m1 = (p_treeness(locvars[v1], locvars[v3])) ? minseg_comp(locvars[v1], locvars[v3]) : INTMAX;
			int m2 = (p_treeness(locvars[v2], locvars[v4])) ? minseg_comp(locvars[v2], locvars[v4]) : INTMAX;
			return (m1 <= m2 ? m1 : m2) == val;
		}
		else return false;
	}
}

bit max_preserve_inv(int val, int v1, int v2, int v3, bit single) {
	assert v1>0 && v1<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE)) return false;
	else if (single)
		return treeness(locvars[v3]) && max_comp(locvars[v3]) == val;
	else {
		//int v1 = gen_non_zero(looplocrange-1);
		//int v2 = gen_non_zero(looplocrange-1)+1;
		assert v1 < v2;
		if (locvars[v1] >= 0 && locvars[v1] < HEAPSIZE
		&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
		&& treeness(locvars[v1]) && treeness(locvars[v2])) {
			int m1 = max_comp(locvars[v1]);
			int m2 = max_comp(locvars[v2]);
			return (m1 <= m2 ? m2 : m1) == val;
		}
		else return false;
	}
}

bit maxseg_preserve_inv(int val, int v1, int v2, int v3, int v4, bit single) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v3>=0 && v3<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE && locvars[v3] >= 0 && locvars[v3] <= HEAPSIZE)) return false;
	else if (single)
		return p_treeness(locvars[v1], locvars[v3]) && maxseg_comp(locvars[v1], locvars[v3]) == val;
	else {
		//int v1 = gen_non_zero(looplocrange-1);
		//int v2 = gen_non_zero(looplocrange-1)+1;
		assert v1 < v2;
		assert v2>0 && v2<LOCVARSIZE;
		assert v4>=0 && v4<LOCVARSIZE;
		if (! (locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
		&& locvars[v4] >= 0 && locvars[v4] < HEAPSIZE)) return false;
		else if (p_treeness(locvars[v1], locvars[v3]) && p_treeness(locvars[v2], locvars[v4])) {
			int m1 = (p_treeness(locvars[v1], locvars[v3])) ? maxseg_comp(locvars[v1], locvars[v3]) : 0;
			int m2 = (p_treeness(locvars[v2], locvars[v4])) ? maxseg_comp(locvars[v2], locvars[v4]) : 0;
			return (m1 <= m2 ? m2 : m1) == val;
		}
		else return false;
	}
}

bit minseg_equal_inv(int v1, int v2, int val) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	int m = p_treeness(locvars[v1], locvars[v2]) ? minseg_comp(locvars[v1], locvars[v2]) : -1;
	return m == val;
}

bit maxseg_equal_inv(int v1, int v2, int val) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	int m = p_treeness(locvars[v1], locvars[v2]) ? maxseg_comp(locvars[v1], locvars[v2]) : -1;
	return m == val;
}

bit lenseg_equal_inv(int v1, int v2, int val) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	int l = p_treeness(locvars[v1], locvars[v2]) ? lenseg_comp(locvars[v1], locvars[v2]) : -1;
	return l == val;
}

bit maxseg_leq_inv(int v1, int v2, int val) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE)) return false;
	int m = p_treeness(locvars[v1], locvars[v2]) ? maxseg_comp(locvars[v1], locvars[v2]) : -1;
	return m <= val;
}

bit max_leq_min_inv(int v1, int v2, int v3, int v4) {
	assert v1>0 && v1<LOCVARSIZE;
	assert v2>0 && v2<LOCVARSIZE;
	assert v3>=0 && v3<LOCVARSIZE;
	assert v4>=0 && v4<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
	&& locvars[v3] >= 0 && locvars[v3] < HEAPSIZE
	&& locvars[v4] >= 0 && locvars[v4] < HEAPSIZE)) return false;
	return (!p_treeness(locvars[v1], locvars[v3])) || (!p_treeness(locvars[v2], locvars[v4]))
			|| maxseg_comp(locvars[v1], locvars[v3]) <= minseg_comp(locvars[v2], locvars[v4]);
	//return (p_treeness(locvars[v1], locvars[v3])) && (p_treeness(locvars[v2], locvars[v4]))
	//	&& maxseg_comp(locvars[v1], locvars[v3]) <= minseg_comp(locvars[v2], locvars[v4]);
}

bit disj_inv(int v1, int v2, int v3, int v4) {
	assert v1>=0 && v1<LOCVARSIZE;
	assert v2>=0 && v2<LOCVARSIZE;
	assert v3>=0 && v3<LOCVARSIZE;
	assert v4>=0 && v4<LOCVARSIZE;
	if (!(locvars[v1] >= 0 && locvars[v1] < HEAPSIZE 
	&& locvars[v2] >= 0 && locvars[v2] < HEAPSIZE
	&& locvars[v3] >= 0 && locvars[v3] < HEAPSIZE
	&& locvars[v4] >= 0 && locvars[v4] < HEAPSIZE)) return false;
	return (!p_treeness(locvars[v1], locvars[v3])) || (!p_treeness(locvars[v2], locvars[v4]))
			|| disjoint(locvars[v1], locvars[v2], locvars[v3], locvars[v4]);
	//return (p_treeness(locvars[v1], locvars[v3])) && (p_treeness(locvars[v2], locvars[v4]))
	//	&& disjoint(locvars[v1], locvars[v2], locvars[v3], locvars[v4]);
}

bit key_disj_inv(bit asst) {
	if (asst)
		assertPost(treeness(locvars[1]) && treeness(locvars[2]));
	bit atom = asst;
	if (treeness(locvars[1]) && treeness(locvars[2])) 
		atom = (max_comp(locvars[2]) <= min_comp(locvars[1]));
	return atom;
}


generator bit predicate(int pred, int locrange, int intrange, int locrange2, int intrange2) {
	assert locrange > 0;
	int aux_loc_var = gen_non_zero(locrange);
	if (pred == SLL) {
		return sll_inv(aux_loc_var);
	}
	else if (pred == RSLL) {
		return rsll_inv(aux_loc_var);
	}
	else if (pred == TREE) {
		return tree_inv(aux_loc_var);
	}
	else {
		int aux_loc_var2 = locrange + gen_non_zero(locrange2);
		int aux_loc_var3 = gen_non_zero(locrange);
		int aux_loc_var4 = locrange + gen_non_zero(locrange2);
		assert aux_loc_var < aux_loc_var2;
		bit d = ??;
		if (pred == NEXTTO) {
			//assert aux_loc_var2 <= locrange;
			if (d) {
				assert aux_loc_var != aux_loc_var3;
				return nextTo(aux_loc_var, aux_loc_var3);
			}
			else {
				assert aux_loc_var2 != aux_loc_var4;
				return nextTo(aux_loc_var2, aux_loc_var4);
			}
		}
		else if (pred == MAXLEQMIN) {
			//assert aux_loc_var2 <= locrange;
			assert aux_loc_var != aux_loc_var3;
			assert aux_loc_var2 != aux_loc_var4;
			return max_leq_min_inv(aux_loc_var, aux_loc_var3, aux_loc_var2, aux_loc_var4);
		}
		else if (pred == DISJ) {
			//assert aux_loc_var2 <= locrange;
			assert aux_loc_var != aux_loc_var3;
			assert aux_loc_var2 != aux_loc_var4;
			return disj_inv(aux_loc_var, aux_loc_var3, aux_loc_var2, aux_loc_var4);
		}
		else if (pred == SLLSEG) {
			if (d) return sllseg_inv(aux_loc_var2, aux_loc_var);
			else return sllseg_inv(aux_loc_var, aux_loc_var2);
		}
		else if (pred == RSLLSEG) {
			if (d) return rsllseg_inv(aux_loc_var2, aux_loc_var);
			else return rsllseg_inv(aux_loc_var, aux_loc_var2);
		}
		else {
			assert intrange+intrange2 > 0;
			int aux_int_var = gen_all(intrange+intrange2);
			if (pred == KEYLEQTO) {
				return keyLeqTo(aux_loc_var, aux_int_var);
			}
			else if (pred == LENSEGEQ) {
				if (d) return lenseg_equal_inv(aux_loc_var2, aux_loc_var, intvars[aux_int_var]);
				else return lenseg_equal_inv(aux_loc_var, aux_loc_var2, intvars[aux_int_var]);
			}
			else if (pred == MAXSEGEQ) {
				if (d) return maxseg_equal_inv(aux_loc_var2, aux_loc_var, intvars[aux_int_var]);
				else return maxseg_equal_inv(aux_loc_var, aux_loc_var2, intvars[aux_int_var]);
			}
			else if (pred == MINSEGEQ) {
				if (d) return minseg_equal_inv(aux_loc_var2, aux_loc_var, intvars[aux_int_var]);
				else return minseg_equal_inv(aux_loc_var, aux_loc_var2, intvars[aux_int_var]);
			}
			else return false;
		}
	}
}

generator bit any_pred(int locrange, int intrange, int locrange2, int intrange2) {
	if (intrange+intrange2 <= 0) return predicate({| TREE | SLL | SLLSEG | NEXTTO | MAXLEQMIN | RSLL | RSLLSEG | DISJ |}, locrange, intrange, locrange2, intrange2);
	else return predicate({| TREE | SLL | SLLSEG | NEXTTO | KEYLEQTO | MAXSEGEQ | MINSEGEQ | LENSEGEQ | MAXLEQMIN | RSLL | RSLLSEG | DISJ |}, locrange, intrange, locrange2, intrange2);
}

generator bit any_literal(int locrange, int intrange, int locrange2, int intrange2) {
	bit res = any_pred(locrange, intrange, locrange2, intrange2);
	if (??) return res;
	else return !res;
}

/*
bit gen_positive_conjuncts() {
	bit res = true;
	if (??) {
		res = res && literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |}, 3, 1);
		if (??) {
			res = res && literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |}, 3, 1);
			if (??) {
				res = res && literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |}, 3, 1);
			}
		}
	}
	//return literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |}) && literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |}) && literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |});

	//minrepeat {
	//	res = res && literal({| SLL | SLLSEG | NEXTTO | KEYLEQTO |});
	//}
	return res;
}
*/

bit basic_axioms() {
	bit r = len(0, ts) == 0 &&
			min(0, ts) == 7 &&
			max(0, ts) == 0;
	int idx = 1;
	while (idx < HEAPSIZE && r) {
		//assume(next[idx]>=0 && next[idx]<HEAPSIZE);
		r = supernext[idx] != 0
		&& len(idx, ts) > 0
		&& min(idx, ts) <= max(idx, ts)
		&& minseg(idx, ts) <= maxseg(idx, ts);
		idx++;
	}
	return r;
}
