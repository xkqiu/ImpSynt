pragma options "--slv-simiters 10 --bnd-inbits 3 --bnd-bound-mode CALLSITE --bnd-inline-amnt 3 --bnd-unroll-amnt 5 ";

int TIMESIZE = 4;
int BOUND = 2;
int INTMAX = 3;
int HEAPSIZE = 6;
int LOCVARSIZE = 4;
int INTVARSIZE = 1;
int MBUDGET = 2;

include "header/bst_header.skh";

int old_bst, old_len, old_min, old_max;

int rank_func_bst_right_rotate = {| 1 |}; //len, min or max

void snapshot_bst_right_rotate(int root, int lchild, ref int obst, ref int omin, ref int omax) {
	obst = bst_comp(locvars[root]);
	omin = min_comp(locvars[root]);
	omax = max_comp(locvars[root]);
}

bit pre_cond_bst_right_rotate(int root, int lchild) {
	return (bst_inv(root) && (leftTo(root, lchild))) && (! (locvar_eq(lchild, 0)));
}

bit post_cond_bst_right_rotate(int r, int root, int lchild, ref int old_min_root, ref int old_max_root, ref int old_min_lchild, ref int old_max_lchild) {
	return ((bst_inv(r) && (rightTo(r, root))) && (locvar_eq(root, 3))) && ((min_equal_inv(r, old_min_root)) && (max_equal_inv(r, old_max_root)));
}

harness void bst_right_rotate(int[LOCVARSIZE-1] llocvars, int[INTVARSIZE] lintvars, int[HEAPSIZE-1] lleft, int[HEAPSIZE-1] lright, int[HEAPSIZE-1] lkey, bit[HEAPSIZE-1] lsymbolic, bit[HEAPSIZE-1] lactive) {

	int[HEAPSIZE-1] lnext = {};
	int[HEAPSIZE-1] lsupernext = {};
	init(llocvars, lintvars, lnext, lsupernext, lleft, lright, lkey, lsymbolic, lactive);

	assume(basic_assumptions() && basic_axioms());

	assume pre_cond_bst_right_rotate(3, 2);

	snapshot_bst_right_rotate(3, 2, old_bst, old_min, old_max);

	ranking_snapshot(rank_func_bst_right_rotate, 2);

	locderef2var(gen_non_zero(3), gen_non_zero(1), ??);
	locMutate(gen_non_zero(3), gen_non_zero(3), ??);
	locMutate(gen_non_zero(3), gen_non_zero(3), ??);
	ret_loc(gen_non_zero(3));

	assertPost(post_cond_bst_right_rotate(ret, 3, 2, old_min, old_max, old_min, old_max));

}
